{
  "version": 3,
  "sources": [],
  "sections": [
    {"offset": {"line": 63, "column": 0}, "map": {"version":3,"sources":["file://G%3A/_dev/hidden_path/arg-game/src/server/db.ts"],"sourcesContent":["import { PrismaClient } from \"@prisma/client\";\n\nconst globalForPrisma = globalThis as unknown as {\n  prisma: PrismaClient | undefined;\n};\n\nexport const prisma =\n  globalForPrisma.prisma ??\n  new PrismaClient({\n    log:\n      process.env.NODE_ENV === \"development\" ? [\"query\", \"error\", \"warn\"] : [\"error\"],\n  });\n\nif (process.env.NODE_ENV !== \"production\") globalForPrisma.prisma = prisma;\n"],"names":[],"mappings":";;;AAAA;;AAEA,MAAM,kBAAkB;AAIjB,MAAM,SACX,gBAAgB,MAAM,IACtB,IAAI,6HAAA,CAAA,eAAY,CAAC;IACf,KACE,uCAAyC;QAAC;QAAS;QAAS;KAAO;AACvE;AAEF,wCAA2C,gBAAgB,MAAM,GAAG"}},
    {"offset": {"line": 77, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 83, "column": 0}, "map": {"version":3,"sources":["file://G%3A/_dev/hidden_path/arg-game/src/app/api/teams/%5BteamId%5D/route.ts"],"sourcesContent":["import { NextResponse } from \"next/server\";\r\nimport { prisma } from \"~/server/db\";\r\nimport { z } from \"zod\";\r\nimport { Player } from \"~/types/team\";\r\n\r\nconst updateTeamSchema = z.object({\r\n    name: z.string().min(1),\r\n    players: z.array(z.object({\r\n        id: z.number(),\r\n        name: z.string().min(1),\r\n        email: z.string().email(),\r\n        phone: z.string().nullable(),\r\n        isTeamLeader: z.boolean(),\r\n        details: z.record(z.unknown()).nullable(),\r\n    })),\r\n});\r\n\r\nexport async function GET(\r\n    req: Request,\r\n    context: { params: Promise<{ teamId: string }> }\r\n) {\r\n    try {\r\n        const { teamId } = await context.params;\r\n        const id = parseInt(teamId);\r\n        if (isNaN(id)) {\r\n            return NextResponse.json(\r\n                { error: \"Invalid team ID\" },\r\n                { status: 400 }\r\n            );\r\n        }\r\n\r\n        const team = await prisma.team.findUnique({\r\n            where: { id },\r\n            select: {\r\n                id: true,\r\n                name: true,\r\n                players: true,\r\n                bookings: {\r\n                    include: {\r\n                        game: {\r\n                            select: {\r\n                                id: true,\r\n                                name: true,\r\n                            },\r\n                        },\r\n                        instance: true,\r\n                    },\r\n                },\r\n            },\r\n        });\r\n\r\n        if (!team) {\r\n            return NextResponse.json(\r\n                { error: \"Team not found\" },\r\n                { status: 404 }\r\n            );\r\n        }\r\n\r\n        // Parse the players JSON string\r\n        const players = JSON.parse(team.players) as Player[];\r\n\r\n        return NextResponse.json({\r\n            team: {\r\n                ...team,\r\n                players,\r\n            }\r\n        });\r\n    } catch (err) {\r\n        console.error(\"Error fetching team:\", err);\r\n        if (err instanceof Error) {\r\n            return NextResponse.json(\r\n                { error: err.message },\r\n                { status: 500 }\r\n            );\r\n        }\r\n        return NextResponse.json(\r\n            { error: \"Failed to fetch team\" },\r\n            { status: 500 }\r\n        );\r\n    }\r\n}\r\n\r\nexport async function DELETE(\r\n    req: Request,\r\n    context: { params: Promise<{ teamId: string }> }\r\n) {\r\n    try {\r\n        const { teamId } = await context.params;\r\n        const id = parseInt(teamId);\r\n        if (isNaN(id)) {\r\n            return NextResponse.json(\r\n                { error: \"Invalid team ID\" },\r\n                { status: 400 }\r\n            );\r\n        }\r\n\r\n        await prisma.team.delete({\r\n            where: { id },\r\n        });\r\n\r\n        return NextResponse.json({ success: true });\r\n    } catch (err) {\r\n        console.error(\"Error deleting team:\", err);\r\n        if (err instanceof Error) {\r\n            return NextResponse.json(\r\n                { error: err.message },\r\n                { status: 500 }\r\n            );\r\n        }\r\n        return NextResponse.json(\r\n            { error: \"Failed to delete team\" },\r\n            { status: 500 }\r\n        );\r\n    }\r\n}\r\n\r\nexport async function PUT(\r\n    req: Request,\r\n    context: { params: Promise<{ teamId: string }> }\r\n) {\r\n    try {\r\n        const { teamId } = await context.params;\r\n        const id = parseInt(teamId);\r\n        if (isNaN(id)) {\r\n            return NextResponse.json(\r\n                { error: \"Invalid team ID\" },\r\n                { status: 400 }\r\n            );\r\n        }\r\n\r\n        const body = await req.json() as z.infer<typeof updateTeamSchema>;\r\n        const result = updateTeamSchema.safeParse(body);\r\n\r\n        if (!result.success) {\r\n            return NextResponse.json(\r\n                { error: \"Invalid input\", details: result.error.flatten() },\r\n                { status: 400 }\r\n            );\r\n        }\r\n\r\n        const { name, players } = result.data;\r\n\r\n        // Update team with players as JSON string\r\n        const updatedTeam = await prisma.team.update({\r\n            where: { id },\r\n            data: {\r\n                name,\r\n                players: JSON.stringify(players)\r\n            },\r\n            select: {\r\n                id: true,\r\n                name: true,\r\n                players: true,\r\n                bookings: {\r\n                    include: {\r\n                        game: {\r\n                            select: {\r\n                                id: true,\r\n                                name: true,\r\n                            },\r\n                        },\r\n                        instance: true,\r\n                    },\r\n                },\r\n            },\r\n        });\r\n\r\n        return NextResponse.json({\r\n            team: {\r\n                ...updatedTeam,\r\n                players: JSON.parse(updatedTeam.players) as Player[]\r\n            }\r\n        });\r\n    } catch (err) {\r\n        console.error(\"Error updating team:\", err);\r\n        if (err instanceof Error) {\r\n            return NextResponse.json(\r\n                { error: err.message },\r\n                { status: 500 }\r\n            );\r\n        }\r\n        return NextResponse.json(\r\n            { error: \"Failed to update team\" },\r\n            { status: 500 }\r\n        );\r\n    }\r\n}\r\n"],"names":[],"mappings":"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"}},
    {"offset": {"line": 273, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}}]
}