{
  "version": 3,
  "sources": [],
  "sections": [
    {"offset": {"line": 63, "column": 0}, "map": {"version":3,"sources":["file://G%3A/_dev/hidden_path/arg-game/src/server/db.ts"],"sourcesContent":["import { PrismaClient } from \"@prisma/client\";\n\nconst globalForPrisma = globalThis as unknown as {\n  prisma: PrismaClient | undefined;\n};\n\nexport const prisma =\n  globalForPrisma.prisma ??\n  new PrismaClient({\n    log:\n      process.env.NODE_ENV === \"development\" ? [\"query\", \"error\", \"warn\"] : [\"error\"],\n  });\n\nif (process.env.NODE_ENV !== \"production\") globalForPrisma.prisma = prisma;\n"],"names":[],"mappings":";;;AAAA;;AAEA,MAAM,kBAAkB;AAIjB,MAAM,SACX,gBAAgB,MAAM,IACtB,IAAI,6HAAA,CAAA,eAAY,CAAC;IACf,KACE,uCAAyC;QAAC;QAAS;QAAS;KAAO;AACvE;AAEF,wCAA2C,gBAAgB,MAAM,GAAG"}},
    {"offset": {"line": 77, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 83, "column": 0}, "map": {"version":3,"sources":["file://G%3A/_dev/hidden_path/arg-game/src/utils/booking-code.ts"],"sourcesContent":["import { prisma } from \"~/server/db\";\r\n\r\n// Characters to use for generating codes (excluding similar looking characters)\r\nexport const CODE_CHARS = \"23456789ABCDEFGHJKLMNPQRSTUVWXYZ\";\r\nexport const CODE_LENGTH = 6;\r\n\r\n/**\r\n * Generates a unique booking code for a team's game session\r\n * Format: XXXXXX (6 characters total)\r\n */\r\nexport async function generateUniqueBookingCode(): Promise<string> {\r\n    let attempts = 0;\r\n    const maxAttempts = 10;\r\n\r\n    while (attempts < maxAttempts) {\r\n        // Generate a random code\r\n        let code = \"\";\r\n        for (let i = 0; i < CODE_LENGTH; i++) {\r\n            code += CODE_CHARS.charAt(Math.floor(Math.random() * CODE_CHARS.length));\r\n        }\r\n\r\n        // Check if code exists\r\n        const existing = await prisma.booking.findUnique({\r\n            where: { code },\r\n        });\r\n\r\n        if (!existing) {\r\n            return code;\r\n        }\r\n\r\n        attempts++;\r\n    }\r\n\r\n    throw new Error(\"Could not generate unique booking code after multiple attempts\");\r\n}\r\n\r\n/**\r\n * Validates a booking code format.\r\n * Booking codes are uppercase alphanumeric strings of 6 characters.\r\n * Input is converted to uppercase before validation.\r\n */\r\nexport function isValidBookingCode(code: string): boolean {\r\n    const upperCode = code.toUpperCase();\r\n    return /^[A-Z0-9]{6}$/.test(upperCode);\r\n}\r\n\r\n/**\r\n * Formats a raw code string into the standard format (XXXXXX)\r\n * @throws Error if code contains invalid characters or length\r\n */\r\nexport function formatBookingCode(code: string): string {\r\n    // Convert to uppercase and remove any non-alphanumeric characters\r\n    const cleaned = code.toUpperCase().replace(/[^A-Z0-9]/g, \"\");\r\n\r\n    // Check if all characters are valid\r\n    const validChars = new RegExp(`^[${CODE_CHARS}]{${CODE_LENGTH}}$`);\r\n    if (!validChars.test(cleaned)) {\r\n        throw new Error(\"Code contains invalid characters or incorrect length\");\r\n    }\r\n\r\n    return cleaned;\r\n} "],"names":[],"mappings":";;;;;;;AAAA;;AAGO,MAAM,aAAa;AACnB,MAAM,cAAc;AAMpB,eAAe;IAClB,IAAI,WAAW;IACf,MAAM,cAAc;IAEpB,MAAO,WAAW,YAAa;QAC3B,yBAAyB;QACzB,IAAI,OAAO;QACX,IAAK,IAAI,IAAI,GAAG,IAAI,aAAa,IAAK;YAClC,QAAQ,WAAW,MAAM,CAAC,KAAK,KAAK,CAAC,KAAK,MAAM,KAAK,WAAW,MAAM;QAC1E;QAEA,uBAAuB;QACvB,MAAM,WAAW,MAAM,qHAAA,CAAA,SAAM,CAAC,OAAO,CAAC,UAAU,CAAC;YAC7C,OAAO;gBAAE;YAAK;QAClB;QAEA,IAAI,CAAC,UAAU;YACX,OAAO;QACX;QAEA;IACJ;IAEA,MAAM,IAAI,MAAM;AACpB;AAOO,SAAS,mBAAmB,IAAY;IAC3C,MAAM,YAAY,KAAK,WAAW;IAClC,OAAO,gBAAgB,IAAI,CAAC;AAChC;AAMO,SAAS,kBAAkB,IAAY;IAC1C,kEAAkE;IAClE,MAAM,UAAU,KAAK,WAAW,GAAG,OAAO,CAAC,cAAc;IAEzD,oCAAoC;IACpC,MAAM,aAAa,IAAI,OAAO,CAAC,EAAE,EAAE,WAAW,EAAE,EAAE,YAAY,EAAE,CAAC;IACjE,IAAI,CAAC,WAAW,IAAI,CAAC,UAAU;QAC3B,MAAM,IAAI,MAAM;IACpB;IAEA,OAAO;AACX"}},
    {"offset": {"line": 130, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 136, "column": 0}, "map": {"version":3,"sources":["file://G%3A/_dev/hidden_path/arg-game/src/app/api/bookings/%5Bcode%5D/answer/route.ts"],"sourcesContent":["import { NextResponse } from \"next/server\";\r\nimport { prisma } from \"~/server/db\";\r\nimport { isValidBookingCode } from \"~/utils/booking-code\";\r\n\r\ninterface AnswerRequest {\r\n    puzzleId: number;\r\n    answer?: string;\r\n    restore?: boolean;\r\n}\r\n\r\nexport async function POST(\r\n    request: Request,\r\n    { params }: { params: Promise<{ code: string }> }\r\n) {\r\n    try {\r\n        const { code } = await params;\r\n        const upperCode = code.toUpperCase();\r\n\r\n        if (!isValidBookingCode(upperCode)) {\r\n            return NextResponse.json(\r\n                { error: \"Invalid booking code format\" },\r\n                { status: 400 }\r\n            );\r\n        }\r\n\r\n        const body = (await request.json()) as AnswerRequest;\r\n        const { puzzleId, answer, restore } = body;\r\n\r\n        // Get booking and related data\r\n        const booking = await prisma.booking.findUnique({\r\n            where: { code: upperCode },\r\n            include: {\r\n                game: {\r\n                    include: {\r\n                        puzzles: {\r\n                            orderBy: { order: \"asc\" },\r\n                        },\r\n                    },\r\n                },\r\n                instance: true,\r\n            },\r\n        });\r\n\r\n        if (!booking) {\r\n            return NextResponse.json(\r\n                { error: \"Invalid booking code\" },\r\n                { status: 400 }\r\n            );\r\n        }\r\n\r\n        // Get current puzzle\r\n        const puzzle = booking.game.puzzles.find(p => p.id === puzzleId);\r\n        if (!puzzle) {\r\n            return NextResponse.json(\r\n                { error: \"Puzzle not found\" },\r\n                { status: 404 }\r\n            );\r\n        }\r\n\r\n        // If this is a restore request, just validate the puzzle exists\r\n        if (restore) {\r\n            return NextResponse.json({\r\n                success: true,\r\n                message: \"Puzzle state restored\",\r\n            });\r\n        }\r\n\r\n        // For actual answer submissions, check if this is the current puzzle\r\n        if (puzzle.order !== booking.instance?.currentPuzzleOrder) {\r\n            return NextResponse.json(\r\n                { error: \"This is not your current puzzle\" },\r\n                { status: 400 }\r\n            );\r\n        }\r\n\r\n        // Check answer (we know answer exists here since restore is false)\r\n        if (puzzle.answer.toLowerCase() === answer!.toLowerCase()) {\r\n            // Find next puzzle\r\n            const nextPuzzle = booking.game.puzzles.find(p => p.order === puzzle.order + 1);\r\n\r\n            // Update instance\r\n            await prisma.gameInstance.update({\r\n                where: { id: booking.instance.id },\r\n                data: {\r\n                    currentPuzzleOrder: nextPuzzle?.order ?? null,\r\n                    completedAt: !nextPuzzle ? new Date() : undefined,\r\n                },\r\n            });\r\n\r\n            return NextResponse.json({\r\n                success: true,\r\n                message: nextPuzzle\r\n                    ? \"Correct! Moving to next puzzle...\"\r\n                    : \"Congratulations! You've completed all puzzles!\",\r\n                nextPuzzle: nextPuzzle ? { id: nextPuzzle.id } : undefined,\r\n            });\r\n        }\r\n\r\n        return NextResponse.json({\r\n            success: false,\r\n            message: \"Incorrect answer, try again!\",\r\n        });\r\n    } catch (error) {\r\n        console.error(\"Error processing answer:\", error);\r\n        return NextResponse.json(\r\n            { error: \"Failed to process answer\" },\r\n            { status: 500 }\r\n        );\r\n    }\r\n} "],"names":[],"mappings":";;;AAAA;AACA;AACA;;;;AAQO,eAAe,KAClB,OAAgB,EAChB,EAAE,MAAM,EAAyC;IAEjD,IAAI;QACA,MAAM,EAAE,IAAI,EAAE,GAAG,MAAM;QACvB,MAAM,YAAY,KAAK,WAAW;QAElC,IAAI,CAAC,CAAA,GAAA,iIAAA,CAAA,qBAAkB,AAAD,EAAE,YAAY;YAChC,OAAO,gIAAA,CAAA,eAAY,CAAC,IAAI,CACpB;gBAAE,OAAO;YAA8B,GACvC;gBAAE,QAAQ;YAAI;QAEtB;QAEA,MAAM,OAAQ,MAAM,QAAQ,IAAI;QAChC,MAAM,EAAE,QAAQ,EAAE,MAAM,EAAE,OAAO,EAAE,GAAG;QAEtC,+BAA+B;QAC/B,MAAM,UAAU,MAAM,qHAAA,CAAA,SAAM,CAAC,OAAO,CAAC,UAAU,CAAC;YAC5C,OAAO;gBAAE,MAAM;YAAU;YACzB,SAAS;gBACL,MAAM;oBACF,SAAS;wBACL,SAAS;4BACL,SAAS;gCAAE,OAAO;4BAAM;wBAC5B;oBACJ;gBACJ;gBACA,UAAU;YACd;QACJ;QAEA,IAAI,CAAC,SAAS;YACV,OAAO,gIAAA,CAAA,eAAY,CAAC,IAAI,CACpB;gBAAE,OAAO;YAAuB,GAChC;gBAAE,QAAQ;YAAI;QAEtB;QAEA,qBAAqB;QACrB,MAAM,SAAS,QAAQ,IAAI,CAAC,OAAO,CAAC,IAAI,CAAC,CAAA,IAAK,EAAE,EAAE,KAAK;QACvD,IAAI,CAAC,QAAQ;YACT,OAAO,gIAAA,CAAA,eAAY,CAAC,IAAI,CACpB;gBAAE,OAAO;YAAmB,GAC5B;gBAAE,QAAQ;YAAI;QAEtB;QAEA,gEAAgE;QAChE,IAAI,SAAS;YACT,OAAO,gIAAA,CAAA,eAAY,CAAC,IAAI,CAAC;gBACrB,SAAS;gBACT,SAAS;YACb;QACJ;QAEA,qEAAqE;QACrE,IAAI,OAAO,KAAK,KAAK,QAAQ,QAAQ,EAAE,oBAAoB;YACvD,OAAO,gIAAA,CAAA,eAAY,CAAC,IAAI,CACpB;gBAAE,OAAO;YAAkC,GAC3C;gBAAE,QAAQ;YAAI;QAEtB;QAEA,mEAAmE;QACnE,IAAI,OAAO,MAAM,CAAC,WAAW,OAAO,OAAQ,WAAW,IAAI;YACvD,mBAAmB;YACnB,MAAM,aAAa,QAAQ,IAAI,CAAC,OAAO,CAAC,IAAI,CAAC,CAAA,IAAK,EAAE,KAAK,KAAK,OAAO,KAAK,GAAG;YAE7E,kBAAkB;YAClB,MAAM,qHAAA,CAAA,SAAM,CAAC,YAAY,CAAC,MAAM,CAAC;gBAC7B,OAAO;oBAAE,IAAI,QAAQ,QAAQ,CAAC,EAAE;gBAAC;gBACjC,MAAM;oBACF,oBAAoB,YAAY,SAAS;oBACzC,aAAa,CAAC,aAAa,IAAI,SAAS;gBAC5C;YACJ;YAEA,OAAO,gIAAA,CAAA,eAAY,CAAC,IAAI,CAAC;gBACrB,SAAS;gBACT,SAAS,aACH,sCACA;gBACN,YAAY,aAAa;oBAAE,IAAI,WAAW,EAAE;gBAAC,IAAI;YACrD;QACJ;QAEA,OAAO,gIAAA,CAAA,eAAY,CAAC,IAAI,CAAC;YACrB,SAAS;YACT,SAAS;QACb;IACJ,EAAE,OAAO,OAAO;QACZ,QAAQ,KAAK,CAAC,4BAA4B;QAC1C,OAAO,gIAAA,CAAA,eAAY,CAAC,IAAI,CACpB;YAAE,OAAO;QAA2B,GACpC;YAAE,QAAQ;QAAI;IAEtB;AACJ"}},
    {"offset": {"line": 242, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}}]
}